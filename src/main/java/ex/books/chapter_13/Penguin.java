package ex.books.chapter_13;

/**
 * 펭귄은 새지만 날 수 없다.
 * 그러나 코드는 '펭귄은 새이며, 따라서 날 수 있다' 라고 말하고 있다.
 * 이는 어휘적인 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야한다는 사실을 잘 보여준다.
 *
 * 만약 새의 정의에 날 수 있다는 행동이 포함되지 않는다면
 * 펭귄은 새의 서브타입이 될 수 있다.
 *
 * 따라서 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다.
 * 행동만 기대한다면 새와 펭귄을 타입 계층으로 묶어도 무방하다.
 * 슈퍼타입과 서브타입 관계에서는 is-a보다 행동 호환성이 더 중요하다.
 */
public class Penguin extends Bird {

  /**
   * 오버라이딩 후 내부 구현을 비워두면 fly 메시지를 전송하더라도 아무 일도 일어나지 않는다.
   * 따라서 Penguin은 날 수 없지만 모든 Bird가 날 수 있다는 클라이언트의 기대를 만족시키지 못한다.
   * 이 설계에서 Penguin과 Bird의 행동은 호환되지 않기 때문에 올바른 타입 계층이라고 할 수 없다.
   */
  @Override
  public void fly() {}
}
